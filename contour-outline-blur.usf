//IMAGE SPACE CONTOUR DETECTION - MAIN OUTLINE - http://www.mva-org.jp/Proceedings/2017USB/papers/09-13.pdf
#pragma once

struct CannyHelpers {
  float grayscale(float3 pixel) {
    return (pixel.r + pixel.g + pixel.b) / 3.0;
  }

  float gaussian_blur_convolution(float3 row1, float3 row2, float3 row3) {
      float3 filter1 = float3(1.0,2.0,1.0);
      float3 filter2 = float3(2.0,4.0,1.0);
      float3 filter3 = float3(1.0,2.0,1.0);
      return dot(filter1,row1) + dot(filter2,row2) + dot(filter3,row3);
  }

  float gaussian_blur(float2 uv, float2 TexelSize) {
    // UV coordinates based on Layout
    // A B C
    // D X E
    // F G H
    float A = grayscale(SceneTextureLookup((float2(-1,1)*TexelSize) + uv,25,false).rgb);
    float B = grayscale(SceneTextureLookup((float2(0,1)*TexelSize) + uv,25,false).rgb);
    float C = grayscale(SceneTextureLookup((float2(1,1)*TexelSize) + uv,25,false).rgb);
    float D = grayscale(SceneTextureLookup((float2(-1,0)*TexelSize) + uv,25,false).rgb);
    float X = grayscale(SceneTextureLookup(uv,25,false).rgb);
    float E = grayscale(SceneTextureLookup((float2(1,0)*TexelSize) + uv,25,false).rgb);
    float F = grayscale(SceneTextureLookup((float2(-1,-1)*TexelSize) + uv,25,false).rgb);
    float G = grayscale(SceneTextureLookup((float2(0,-1)*TexelSize) + uv,25,false).rgb);
    float H = grayscale(SceneTextureLookup((float2(1,-1)*TexelSize) + uv,25,false).rgb);
    //weighted avg so that you don't lighten or darken a pixel
    float blurred_pixel = gaussian_blur(float3(A,B,C),float3(D,X,E),float3(F,G,H))/9.0;
    return blurred_pixel;
  }

  float sobel_operation(float3 vec1, float3 vec2) {
      float3 filter1 = float3(-1.0,-2.0,-1.0);
      float3 filter2 = float3(1.0,2.0,1.0);
      return dot(filter1,vec1) + dot(filter2,vec2);
  }

  float3 sobel_gradient(float2 uv, float2 TexelSize, int textureID) {
    // UV coordinates based on Layout
    // A B C
    // D X E
    // F G H
    float3 A = grayscale(SceneTextureLookup((float2(-1,1)*TexelSize) + uv,textureID,false).rgb);
    float3 B = grayscale(SceneTextureLookup((float2(0,1)*TexelSize) + uv,textureID,false).rgb);
    float3 C = grayscale(SceneTextureLookup((float2(1,1)*TexelSize) + uv,textureID,false).rgb);
    float3 D = grayscale(SceneTextureLookup((float2(-1,0)*TexelSize) + uv,textureID,false).rgb);
    float3 E = grayscale(SceneTextureLookup((float2(1,0)*TexelSize) + uv,textureID,false).rgb);
    float3 F = grayscale(SceneTextureLookup((float2(-1,-1)*TexelSize) + uv,textureID,false).rgb);
    float3 G = grayscale(SceneTextureLookup((float2(0,-1)*TexelSize) + uv,textureID,false).rgb);
    float3 H = grayscale(SceneTextureLookup((float2(1,-1)*TexelSize) + uv,textureID,false).rgb);

    //sobel x & y differential on grayscaled value
    float dIx = abs(sobel_operation(float3(A,D,F),float3(C,E,H)));
    float dIy = abs(sobel_operation(float3(A,B,C),float3(F,G,H)));

    //identifying grad_x & grad_y
    float dI = sqrt(pow(dIx,2.0)+pow(dIy,2.0));
    return float3(dIx,dIy,dI);
  }
  //commment
  float2 non_maximum_suppression_double_threshold(float2 uv, float2 TexelSize, float lower, float upper, int textureID) {
    //step 1 get the sobel magnitude
    float3 sobel_grad = sobel_gradient(uv,TexelSize,textureID);
    //step 2 Non-Maximum Suppression
    float theta = atan(sobel_grad.y/sobel_grad.x);
    float2x2 rotation_matrix = float2x2(cos(theta),-sin(theta), sin(theta), cos(theta));
    float2 offset_left = mul(float2(-1,0)*TexelSize,rotation_matrix);
    float2 offset_right = mul(float2(1,0)*TexelSize,rotation_matrix);
    float3 sobel_grad_left = sobel_gradient(uv+offset_left,TexelSize,textureID);
    float3 sobel_grad_right = sobel_gradient(uv+offset_right,TexelSize,textureID);
    float edge = sobel_grad.z;
    if ((edge < sobel_grad_left.z) || (edge < sobel_grad_right.z)) {
      edge = 0;
    }
    //step 3 double threshold
    float2 threshold_response = float2(edge > lower ? edge : 0, edge > upper ? edge : 0);
    return threshold_response;
  }
}; CannyHelpers c_h;

float stencilIndex = 1;
float2 uv = GetDefaultSceneTextureUV(Parameters,14);
if (SceneTextureLookup(uv,25,false).r == stencilIndex) {
  float2 TexelSize = View.ViewSizeAndInvSize.zw;
  // float lower = 0.2;
  // float upper = 0.6;
  //step 1 get the sobel magnitude
  float2 threshold_response = c_h.non_maximum_suppression_double_threshold(uv,TexelSize,lower,upper,textureID);

  /*
  threshold_response = (lower_response,upper_response)
  (0,0) -> not an edge
  (edge, 0) -> potentially an edge
  (0,edge) -> not possible
  (edge, edge) -> positive edge
  */


  if (threshold_response.x == 0.0 && threshold_response.y == 0.0) {
    //not an edge
    return 0.0;
  } else if (threshold_response.y > 0.0) {
    //strong response
    return 1.0;
  } else {
    //weak response
    //step 4 edge tracking by hysteresis
    //this is a weak pixel, if it surrounded by a strong pixel then set this one to strong
    // UV coordinates based on Layout
    // A B C
    // D X E
    // F G H
    for (int y = 1; y >= -1; y--) {
      for (int x = -1; x <= 1; x++) {
        //get A...H
        float2 uv_offset = (float2(x,y) * TexelSize) + uv;
        //check if it is a strong response
        float2 hysteresis_threshold_response = c_h.non_maximum_suppression_double_threshold(uv_offset,TexelSize,lower,upper,textureID);
        if (hysteresis_threshold_response.y > 0.0) {
          //if it is then this weak response is an edge
          return 1.0;
        }
      }
    }
  }
}
return 0.0;
