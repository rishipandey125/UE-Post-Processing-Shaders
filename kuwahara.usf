#pragma once
//normalize the z value
//calculate the correct radius
//potential sol: https://answers.unrealengine.com/questions/723922/scene-depth-capture-does-not-work.html
float2 uv = GetDefaultSceneTextureUV(Parameters, 14);
float normalized_depth = ndv.normalize_depth(uv);
const int radius = 6;
float n = float(radius * radius);
float3 zero = float3(0, 0, 0);
float3 mean[4] = {zero, zero, zero, zero};
float3 var[4] = {zero, zero, zero, zero};
int l = radius - 1;
//Screen Size
float2 TexelSize = View.ViewSizeAndInvSize.zw;
// Bottom Left Sub-Grid
int y = 0;
int x = 0;
float3 pix;
for (y = (-1*l); y <= 0; y++) {
  for (x = (-1*l); x <= 0; x++) {
    float2 offset = float2(x,y)*TexelSize;
    pix = SceneTextureLookup(uv + offset,14,false).rgb;
    mean[0] += pix;
    var[0] += pix*pix;
  }
}

//Bottom Right Sub-Grid
for (y = (-1*l); y <= 0; y++) {
  for (x = l; x >= 0; x--) {
    float2 offset = float2(x,y)*TexelSize;
    pix = SceneTextureLookup(uv + offset,14,false).rgb;
    mean[1] += pix;
    var[1] += pix*pix;
  }
}

//Top Left Sub-Grid
for (y = l; y >= 0; y--) {
  for (x = (-1*l); x <= 0; x++) {
    float2 offset = float2(x,y)*TexelSize;
    pix = SceneTextureLookup(uv + offset,14,false).rgb;
    mean[2] += pix;
    var[2] += pix*pix;
  }
}

//Top Right Sub-Grid
for (y = l; y >= 0; y--) {
  for (x = l; x >= 0; x--) {
    float2 offset = float2(x,y)*TexelSize;
    pix = SceneTextureLookup(uv + offset,14,false).rgb;
    mean[3] += pix;
    var[3] += pix*pix;
  }
}

// Selecting Correct Pixel Based on Lowest Variance
float min_var = 1e+4;
float3 color;
for (int i = 0; i < 4; i++) {
  mean[i] /= n;
  float3 variance = abs((var[i]/n) - (mean[i]*mean[i]));
  float v = variance.r + variance.g + variance.b;
  if (v < min_var) {
    min_var = v;
    color = mean[i];
  }
}
//generating random canvas texture
struct RandomNumber {
  float random(float2 input) {
    float2 K1 = float2(
      23.14069263277926, // e^pi (Gelfond's constant)
      2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)
    );
    return frac(cos(dot(input,K1)) * 12345.6789);
  }
};
RandomNumber r;
/*
the reason this doesnt work is because every frame will compute the same uv cord since the seed
which is the camera_pos is the same for every pixel in the image
each image will have the same canvas
the seed must determine how the image is scattered and retrieved not the literal uv
*/
float canvas_x = uv.x;
float canvas_y = uv.y;
if (time % 3 == 0) {
  canvas_x = r.random(float2(uv.x,time));
  canvas_y = r.random(float2(uv.y,time));
}
float3 canvas_texture_color = Texture2DSample(Tex, TexSampler, float2(canvas_x,canvas_y));
// Output Correct Color
return SceneTextureLookup(uv,1,false).r*0.0001;
// return color*canvas_texture_color;
